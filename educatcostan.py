# -*- coding: utf-8 -*-
"""Educatcostan

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x06rgKg_Bu6E7HD5EKk_QbFyhIi7Z3pt
"""
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.cluster import KMeans
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.ensemble import RandomForestRegressor
from sklearn.ensemble import GradientBoostingRegressor

# стиль графика
sns.set(style="whitegrid")

# загрузка датасета
df = pd.read_csv('/content/tuition_graduate .csv')
df.info()
print("Первые 15 строк :")
print(df.head(50))

# Предварительный анализ данных

print("\nИнформация о датасете:")
print(df.info())

print("\nСтатистическое описание числовых признаков:")
print(df.describe())

print("\nКоличество пропущенных значений в каждом столбце:")
print(df.isnull().sum())

# Визуализация данных
if 'cost' in df.columns:
    plt.figure(figsize=(10, 6))
    sns.histplot(df['cost'], bins=30, kde=True)
    plt.title('Распределение цен на образовательные услуги')
    plt.xlabel('Цена')
    plt.ylabel('Частота')
    plt.show()
else:
    print("В датасете нет столбца 'cost' для визуализации.")

# средняя цена по курсам
if 'school' in df.columns and 'cost' in df.columns:
    plt.figure(figsize=(12, 6))
    sns.boxplot(x='school', y='cost', data=df)
    plt.title('Цены на образовательные услуги по категориям')
    plt.xlabel('Направление')
    plt.ylabel('Цена')
    plt.xticks(rotation=45)
    plt.show()
else:
    print("В датасете нет необходимых столбцов для визуализации по категориям.")

# Группировка данных по категориям и вычисление средней цены
if 'school' in df.columns and 'cost' in df.columns:
    average_cost_per_school = df.groupby('school')['cost'].mean().reset_index()
    print("\nСредняя цена на образовательные услуги по направлениям:")
    print(average_cost_per_school)
else:
    print("В датасете нет необходимых столбцов для расчета средней цены.")

# Заполнение пропусков
df['academic.year'].fillna(df['academic.year'].median(), inplace=True)
df['cost'].fillna('Unknown', inplace=True)

df = df[df['cost'] != 'Unknown']

# числовые и категориальные признаки
numerical_features = ['academic.year',]
categorical_features = ['school']
label_encoder = LabelEncoder()
df['school'] = label_encoder.fit_transform(df['school'])


# Проверка на наличие пропусков
print(df_encoded.isnull().sum())

# Определение переменных X и y
X = df[['school']]  # Используем только 'school' для визуализации
y = df['cost']  # Целевая переменная

# трансформер для предобработки
preprocessor = ColumnTransformer(
    transformers=[
        ('num', StandardScaler(), numerical_features),  # Стандартизация числовых признаков
        ('cat', OneHotEncoder(), categorical_features)   # Кодирование категориальных признаков
    ])

#  Разделение данных на обучающую и тестовую выборки
X = df[['cost']]
y = df[['academic.year']]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Применение предобработки с помощью Pipeline
pipeline = Pipeline(steps=[('preprocessor', preprocessor)])

df.info()
print(df.head(50))

# Гистограмма
plt.subplot(1, 2, 1)
sns.histplot(df['cost'], bins=10, kde=True)
plt.title('Цена')
plt.ylabel('Среднее')

# Диаграмма
plt.subplot(1, 2, 2)
sns.scatterplot(data=df, x='cost', y='academic.year', hue='school', style='school', s=100)
plt.title('Цена за год')
plt.ylabel('Год обучения')

plt.tight_layout()
plt.show()

# Визуализация кластеров
plt.figure(figsize=(10, 6))
sns.scatterplot(data=df, x='cost', y='school', hue='cluster', palette='viridis', s=100)
plt.title('Изменение цен на обучение')
plt.xlabel('Цена')
plt.ylabel('Направление')
plt.legend(title='Кластер')
plt.show()

# Параметры для многократного обучения
num_iterations = 100
mse_list = []
r2_list = []

for _ in range(num_iterations):
    # Разделение данных на обучающую и тестовую выборки
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=None)  # Убираем random_state для случайности

    # Сохранение метрик
    mse_list.append(mse)
    r2_list.append(r2)

# Вывод средних значений метрик
average_mse = np.mean(mse_list)
average_r2 = np.mean(r2_list)

# Создание модели линейной регрессии
model = LinearRegression()

# Обучение модели
model.fit(X_train, y_train)

# Прогнозирование на тестовой выборке
y_pred = model.predict(X_test)

# Визуализация
plt.figure(figsize=(11, 7))

# Отображаем фактические значения
plt.scatter(X, y, color='blue', label='Фактические значения')

# Отображаем предсказанные значения
plt.scatter(X_test, y_pred, color='red', label='Спрогнозированные значения')

# Линия линейной регрессии
x_range = np.linspace(X['cost'].min(), X['cost'].max(), 100).reshape(-1, 1)
y_range = model.predict(x_range)
plt.plot(x_range, y_range, color='green', label='Линия регрессии')

# Настройка графика
plt.title('Линейная регрессия: стоимость по временному интервалу')
plt.xlabel('Цена (кодированная)')
plt.ylabel('Год')
plt.xticks(ticks=np.arange(len(label_encoder.classes_)), labels=label_encoder.classes_)
plt.legend()
plt.grid()
plt.show()

# Оценка модели
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

# Сохранение метрик
mse_list.append(mse)
r2_list.append(r2)

# Вывод результатов
print(f'Mean Squared Error: {mse}')
print(f'R^2 Score: {r2}')

# Вывод коэффициентов модели
coefficients = pd.DataFrame(model.coef_, X.columns, columns=['коэффициэнт'])
print(coefficients)

# Вывод средних значений метрик
average_mse = np.mean(mse_list)
average_r2 = np.mean(r2_list)

print(f'Средняя MSE за {num_iterations} итераций: {average_mse}')
print(f'Средний R^2 Score за {num_iterations} итераций: {average_r2}')

# Визуализация результатов
plt.figure(figsize=(12, 6))

# Гистограмма MSE
plt.subplot(1, 2, 1)
plt.hist(mse_list, bins=10, color='skyblue', edgecolor='black')
plt.title('Распределение MSE')
plt.xlabel('MSE')
plt.ylabel('Частота')

# Гистограмма R²
plt.subplot(1, 2, 2)
plt.hist(r2_list, bins=10, color='salmon', edgecolor='black')
plt.title('Распределение R²')
plt.xlabel('R² Score')
plt.ylabel('Частота')

plt.tight_layout()
plt.show()

# Преобразование категориальных переменных в фиктивные переменные
X = pd.get_dummies(df[['school']], drop_first=True)
y = df['cost']

# Параметры для многократного обучения
num_iterations = 100
mse_list = []
r2_list = []

for _ in range(num_iterations):
    # Разделение данных на обучающую и тестовую выборки
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=None)

    # Создание модели случайного леса
    model = RandomForestRegressor(n_estimators=100, random_state=None)

    # Обучение модели
    model.fit(X_train, y_train)

    # Прогнозирование на тестовой выборке
    y_pred = model.predict(X_test)

    # Оценка модели
    mse = mean_squared_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)

    # Сохранение метрик
    mse_list.append(mse)
    r2_list.append(r2)

# Вывод средних значений метрик
average_mse = np.mean(mse_list)
average_r2 = np.mean(r2_list)

print(f'Средняя MSE за {num_iterations} итераций: {average_mse}')
print(f'Средний R^2 Score за {num_iterations} итераций: {average_r2}')

# Визуализация результатов
plt.figure(figsize=(12, 6))

# Гистограмма MSE
plt.subplot(1, 2, 1)
plt.hist(mse_list, bins=10, color='skyblue', edgecolor='black')
plt.title('Распределение MSE (Случайный Лес)')
plt.xlabel('MSE')
plt.ylabel('Частота')

# Гистограмма R²
plt.subplot(1, 2, 2)
plt.hist(r2_list, bins=10, color='salmon', edgecolor='black')
plt.title('Распределение R² (Случайный Лес)')
plt.xlabel('R² Score')
plt.ylabel('Частота')

plt.tight_layout()
plt.show()

# Параметры для многократного обучения
num_iterations = 100
mse_list = []
r2_list = []

for _ in range(num_iterations):
    # Разделение данных на обучающую и тестовую выборки
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=None)

    # Создание модели градиентного бустинга
    model = GradientBoostingRegressor(n_estimators=100, random_state=None)

    # Обучение модели
    model.fit(X_train, y_train)

    # Прогнозирование на тестовой выборке
    y_pred = model.predict(X_test)

    # Оценка модели
    mse = mean_squared_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)

    # Сохранение метрик
    mse_list.append(mse)
    r2_list.append(r2)

# Вывод средних значений метрик
average_mse = np.mean(mse_list)
average_r2 = np.mean(r2_list)

print(f'Средняя MSE за {num_iterations} итераций: {average_mse}')
print(f'Средний R^2 Score за {num_iterations} итераций: {average_r2}')

# Визуализация результатов
plt.figure(figsize=(12, 6))

# Гистограмма MSE
plt.subplot(1, 2, 1)
plt.hist(mse_list, bins=10, color='skyblue', edgecolor='black')
plt.title('Распределение MSE (Градиентный Бустинг)')
plt.xlabel('MSE')
plt.ylabel('Частота')

# Гистограмма R²
plt.subplot(1, 2, 2)
plt.hist(r2_list, bins=10, color='salmon', edgecolor='black')
plt.title('Распределение R² (Градиентный Бустинг)')
plt.xlabel('R² Score')
plt.ylabel('Частота')

plt.tight_layout()
plt.show()

# Сравнение моделей лес и бустинг

# Визуализация результатов
labels = ['Случайный лес', 'Градиентный бустинг']
mse_values = [rf_mse, gb_mse]
r2_values = [rf_r2, gb_r2]

x = np.arange(len(labels))

fig, ax = plt.subplots(1, 2, figsize=(12, 5))

# Гистограмма MSE
ax[0].bar(x, mse_values, color=['skyblue', 'salmon'], edgecolor='black')
ax[0].set_xticks(x)
ax[0].set_xticklabels(labels)
ax[0].set_title('Сравнение MSE')
ax[0].set_ylabel('MSE')

# Гистограмма R²
ax[1].bar(x, r2_values, color=['skyblue', 'salmon'], edgecolor='black')
ax[1].set_xticks(x)
ax[1].set_xticklabels(labels)
ax[1].set_title('Сравнение R² Score')
ax[1].set_ylabel('R² Score')

plt.tight_layout()
plt.show()

# Вывод результатов
print("Случайный лес:")
print(f"Средняя MSE: {rf_mse:.2f}")
print(f"R² Score: {rf_r2:.2f}")

print("\nГрадиентный бустинг:")
print(f"Средняя MSE: {gb_mse:.2f}")
print(f"R² Score: {gb_r2:.2f}")

# Визуализация результатов прогноза
plt.figure(figsize=(10, 6))
plt.scatter(y_test, rf_pred, color='blue', label='Случайный лес', alpha=0.6)
plt.scatter(y_test, gb_pred, color='orange', label='Градиентный бустинг', alpha=0.6)
plt.plot([y.min(), y.max()], [y.min(), y.max()], 'k--', lw=2)  # Линия идеальных предсказаний
plt.xlabel('Фактические значения')
plt.ylabel('Предсказанные значения')
plt.title('Сравнение результатов прогноза')
plt.legend()
plt.grid()
plt.show()

# Вывод результатов
print("Случайный лес:")
print(f"Средняя MSE: {rf_mse:.2f}")
print(f"R² Score: {rf_r2:.2f}")

print("\nГрадиентный бустинг:")
print(f"Средняя MSE: {gb_mse:.2f}")
print(f"R² Score: {gb_r2:.2f}")

# Визуализация метрик
metrics = pd.DataFrame({
    'Model': ['Случайный лес', 'Градиентный бустинг'],
    'MSE': [rf_mse, gb_mse],
    'R² Score': [rf_r2, gb_r2]
})

metrics.set_index('Model', inplace=True)

# Построение графика
metrics.plot(kind='bar', figsize=(10, 6))
plt.title('Сравнение метрик MSE и R² Score')
plt.ylabel('Значение')
plt.xticks(rotation=0)
plt.grid(axis='y')
plt.show()
